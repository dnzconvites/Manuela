<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>teste</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }

    #camera-wrap {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: black;
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: black;
    }

    #brilhosCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #frame {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* BOTÕES (IMAGENS) */
    #buttons {
      position: fixed;
      bottom: 25px;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 22px;
      z-index: 20;
    }

    .btn-img {
      width: 75px;
      height: 75px;
      cursor: pointer;
      user-select: none;
      transition: 0.15s ease;
      border-radius: 50%;
    }

    .btn-img:active {
      transform: scale(0.87);
      opacity: 0.8;
    }

    #download { display: none; }
  </style>
</head>
<body>

  <div id="camera-wrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="brilhosCanvas"></canvas>

    <!-- Somente UMA moldura agora -->
    <img id="frame" src="moldura.png">

    <img id="brilhoImg" src="brilho.png" style="display:none;">
  </div>

  <!-- BOTÕES EM IMAGEM (apenas 2 agora) -->
  <div id="buttons">
    <img id="switchBtn" class="btn-img" src="trocarcamera.png">
    <img id="snapBtn" class="btn-img" src="tirarfoto.png">
  </div>

  <a id="download" download="fotomoldurapersonalizada.png"></a>

  <script>
    const video = document.getElementById("video");
    const frame = document.getElementById("frame");
    const snapBtn = document.getElementById("snapBtn");
    const switchBtn = document.getElementById("switchBtn");
    const download = document.getElementById("download");

    const brilhosCanvas = document.getElementById("brilhosCanvas");
    const bCtx = brilhosCanvas.getContext("2d");

    const brilhoImg = document.getElementById("brilhoImg");

    let stream = null;
    let usingFront = true;
    let brilhos = [];
    const MAX_BRILHOS = 15;

    function criarBrilho() {
      brilhos.push({
        x: Math.random() * 100,
        y: Math.random() * 100,
        size: Math.random() * 20 + 10,
        opacity: Math.random() * 0.5 + 0.5,
        dx: (Math.random() - 0.5) * 0.3,
        dy: (Math.random() - 0.5) * 0.3,
        dOpacity: (Math.random() - 0.5) * 0.02
      });
      if (brilhos.length > MAX_BRILHOS) brilhos.shift();
    }

    function desenharBrilho(ctx, brilho, canvasWidth, canvasHeight) {
      const x = brilho.x * (canvasWidth / 100);
      const y = brilho.y * (canvasHeight / 100);
      const r = brilho.size;

      ctx.save();
      ctx.globalAlpha = brilho.opacity;
      ctx.drawImage(brilhoImg, x - r / 2, y - r / 2, r, r);
      ctx.restore();
    }

    function atualizarBrilhos() {
      brilhos.forEach(b => {
        b.x += b.dx;
        b.y += b.dy;
        b.opacity += b.dOpacity;

        if (b.opacity <= 0) {
          b.opacity = 0;
          b.dOpacity = Math.abs(b.dOpacity);
        } else if (b.opacity >= 1) {
          b.opacity = 1;
          b.dOpacity = -Math.abs(b.dOpacity);
        }

        if (b.x < -10 || b.x > 110 || b.y < -10 || b.y > 110) {
          b.x = Math.random() * 100;
          b.y = Math.random() * 100;
          b.size = Math.random() * 20 + 10;
          b.opacity = Math.random() * 0.5 + 0.5;
          b.dx = (Math.random() - 0.5) * 0.3;
          b.dy = (Math.random() - 0.5) * 0.3;
          b.dOpacity = (Math.random() - 0.5) * 0.02;
        }
      });
    }

    function animarBrilhosRealtime() {
      bCtx.clearRect(0, 0, brilhosCanvas.width, brilhosCanvas.height);
      atualizarBrilhos();
      brilhos.forEach(brilho =>
        desenharBrilho(bCtx, brilho, brilhosCanvas.width, brilhosCanvas.height)
      );
      requestAnimationFrame(animarBrilhosRealtime);
    }

    function waitForVideoReady() {
      return new Promise(resolve => {
        if (video.readyState >= 2 && video.videoWidth > 0) resolve();
        else video.onloadedmetadata = () => resolve();
      });
    }

    async function startCamera() {
      if (stream) stream.getTracks().forEach(t => t.stop());

      const constraints = { video: { facingMode: usingFront ? "user" : "environment" } };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      video.style.transform = usingFront ? "scaleX(-1)" : "scaleX(1)";

      await waitForVideoReady();

      brilhosCanvas.width = video.videoWidth;
      brilhosCanvas.height = video.videoHeight;

      brilhos = [];
      for (let i = 0; i < MAX_BRILHOS; i++) criarBrilho();

      animarBrilhosRealtime();
    }

    switchBtn.addEventListener("click", () => {
      usingFront = !usingFront;
      startCamera();
    });

    snapBtn.addEventListener("click", async () => {
      await waitForVideoReady();

      const vw = video.videoWidth;
      const vh = video.videoHeight;
      const targetW = 720;
      const targetH = 1280;

      const canvas = document.createElement("canvas");
      canvas.width = targetW;
      canvas.height = targetH;
      const ctx = canvas.getContext("2d");

      ctx.save();
      if (usingFront) {
        ctx.translate(targetW, 0);
        ctx.scale(-1, 1);
      }

      const videoRatio = vw / vh;
      const targetRatio = targetW / targetH;
      let sx, sy, sw, sh;

      if (videoRatio > targetRatio) {
        sh = vh;
        sw = sh * targetRatio;
        sx = (vw - sw) / 2;
        sy = 0;
      } else {
        sw = vw;
        sh = sw / targetRatio;
        sx = 0;
        sy = (vh - sh) / 2;
      }

      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, targetW, targetH);
      ctx.restore();

      /* Somente 1 moldura agora */
      ctx.drawImage(frame, 0, 0, targetW, targetH);

      brilhos.forEach(brilho => desenharBrilho(ctx, brilho, targetW, targetH));

      download.href = canvas.toDataURL("image/png");
      download.click();
    });

    startCamera();
  </script>

</body>
</html>
